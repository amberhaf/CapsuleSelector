{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.DroppableDayWrapper = exports.DroppableDateCellWrapper = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDnd = require('react-dnd');\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _propTypes3 = require('../../utils/propTypes');\n\nvar _accessors = require('../../utils/accessors');\n\nvar _dates = require('../../utils/dates');\n\nvar _dates2 = _interopRequireDefault(_dates);\n\nvar _index = require('../../index');\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction getEventDropProps(start, end, dropDate, droppedInAllDay) {\n  // Calculate duration between original start and end dates\n  var duration = _dates2.default.diff(start, end);\n  /*\n   * If the event is dropped in a \"Day\" cell, preserve an event's start time by extracting the hours and minutes off\n   * the original start date and add it to newDate.value\n   *\n   * note: this behavior remains for backward compatibility, but might be counter-intuitive to some:\n   * dragging an event from the grid to the day header might more commonly mean \"make this an allDay event\n   * on that day\" - but the behavior here implements \"keep the times of the event, but move it to the\n   * new day\".\n   *\n   * To permit either interpretation, we embellish a new `allDay` parameter which determines whether the\n   * event was dropped on the day header or not.\n   */\n\n\n  var nextStart = droppedInAllDay ? _dates2.default.merge(dropDate, start) : dropDate;\n\n  var nextEnd = _dates2.default.add(nextStart, duration, 'milliseconds');\n\n  return {\n    start: nextStart,\n    end: nextEnd,\n    allDay: droppedInAllDay\n  };\n}\n\nvar DropWrapper = function (_React$Component) {\n  _inherits(DropWrapper, _React$Component);\n\n  function DropWrapper() {\n    _classCallCheck(this, DropWrapper);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  } // TODO: this is WIP to retain the drag offset so the\n  // drag target better tracks the mouseDown location, not\n  // just the top of the event.\n  //\n  // constructor(...args) {\n  //   super(...args);\n  //   this.state = { isOver: false };\n  // }\n  //\n  // componentWillMount() {\n  //   let monitor = this.context.dragDropManager.getMonitor()\n  //\n  //   this.monitor = monitor\n  //\n  //   this.unsubscribeToStateChange = monitor\n  //     .subscribeToStateChange(this.handleStateChange)\n  //\n  //   this.unsubscribeToOffsetChange = monitor\n  //     .subscribeToOffsetChange(this.handleOffsetChange)\n  // }\n  //\n  // componentWillUnmount() {\n  //   this.monitor = null\n  //   this.unsubscribeToStateChange()\n  //   this.unsubscribeToOffsetChange()\n  // }\n  //\n  // handleStateChange = () => {\n  //   const event = this.monitor.getItem();\n  //   if (!event && this.state.isOver) {\n  //     this.setState({ isOver: false });\n  //   }\n  // }\n  //\n  // handleOffsetChange = () => {\n  //   const { value } = this.props;\n  //   const { start, end } = this.monitor.getItem();\n  //\n  //   const isOver = dates.inRange(value, start, end, 'minute');\n  //   if (this.state.isOver !== isOver) {\n  //     this.setState({ isOver });\n  //   }\n  // };\n\n\n  DropWrapper.prototype.render = function render() {\n    var _props = this.props,\n        connectDropTarget = _props.connectDropTarget,\n        children = _props.children,\n        isOver = _props.isOver,\n        range = _props.range,\n        type = _props.type,\n        value = _props.value; // Check if wrapper component of this type was passed in, otherwise use library default\n\n    var components = this.context.components;\n    var BackgroundWrapper = components[type] || _index2.default.components[type];\n    var backgroundWrapperProps = {\n      value: value\n    };\n\n    if (range) {\n      backgroundWrapperProps.range = range;\n    }\n\n    var resultingChildren = children;\n\n    if (isOver) {\n      resultingChildren = _react2.default.cloneElement(children, {\n        className: (0, _classnames2.default)(children.props.className, 'rbc-addons-dnd-over')\n      });\n    }\n\n    return _react2.default.createElement(BackgroundWrapper, backgroundWrapperProps, connectDropTarget(resultingChildren));\n  };\n\n  return DropWrapper;\n}(_react2.default.Component);\n\nDropWrapper.propTypes = {\n  connectDropTarget: _propTypes2.default.func.isRequired,\n  isOver: _propTypes2.default.bool,\n  range: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(Date)),\n  type: _propTypes2.default.string,\n  value: _propTypes2.default.instanceOf(Date)\n};\nDropWrapper.contextTypes = {\n  onEventDrop: _propTypes2.default.func,\n  onEventResize: _propTypes2.default.func,\n  components: _propTypes2.default.object,\n  dragDropManager: _propTypes2.default.object,\n  startAccessor: _propTypes3.accessor,\n  endAccessor: _propTypes3.accessor,\n  allDayAccessor: _propTypes3.accessor,\n  step: _propTypes2.default.number\n};\n\nfunction createDropWrapper(type) {\n  function collectTarget(connect, monitor) {\n    return {\n      type: type,\n      connectDropTarget: connect.dropTarget(),\n      isOver: monitor.isOver()\n    };\n  }\n\n  var dropTarget = {\n    drop: function drop(_, monitor, _ref) {\n      var props = _ref.props,\n          context = _ref.context;\n      var itemType = monitor.getItemType();\n      if (itemType !== 'event') return;\n      var item = monitor.getItem();\n      var event = item.event,\n          anchor = item.anchor;\n      var value = props.value,\n          resource = props.resource;\n      var _context$onEventDrop = context.onEventDrop,\n          onEventDrop = _context$onEventDrop === undefined ? _noop2.default : _context$onEventDrop,\n          _context$onEventResiz = context.onEventResize,\n          onEventResize = _context$onEventResiz === undefined ? _noop2.default : _context$onEventResiz,\n          startAccessor = context.startAccessor,\n          endAccessor = context.endAccessor,\n          allDayAccessor = context.allDayAccessor,\n          step = context.step;\n      var start = (0, _accessors.accessor)(event, startAccessor);\n      var end = (0, _accessors.accessor)(event, endAccessor);\n      var allDay = (0, _accessors.accessor)(event, allDayAccessor);\n      var droppedInAllDay = type === 'dateCellWrapper';\n\n      switch (anchor) {\n        case 'drop':\n          onEventDrop(_extends({\n            event: event\n          }, getEventDropProps(start, end, value, droppedInAllDay), {\n            resourceId: resource\n          }));\n          return;\n        // all the other cases issue resize action...\n        // the remaining cases are all resizes...\n\n        case 'resizeTop':\n          // dragging the top means the event isn't an allDay\n          // dropping into the header changes the date, preserves the time\n          // dropping elsewhere is just a normal resize\n          start = droppedInAllDay ? _dates2.default.merge(value, start) : value;\n          break;\n\n        case 'resizeBottom':\n          // dragging the bottom means the event isn't an allDay\n          // dropping into the header changes the date, preserves the time\n          // dropping elsewhere is just a normal resize\n          // ... but end dates are exclusive so advance it the next slot (e.g. just past the end of this one)\n          end = droppedInAllDay ? _dates2.default.merge(value, end) : _dates2.default.add(value, step, 'minutes');\n          break;\n\n        case 'resizeLeft':\n          // dragging the left means we're dragging something from an event row\n          // all cases are the same:\n          // preserve its start time, but change the date (works for both allDay and non-allDay)\n          start = _dates2.default.merge(value, start);\n          break;\n\n        case 'resizeRight':\n          // dragging the right means we're dragging something from an event row\n          // this case is tricky: for non-allDay events, we just want to change\n          // the end date (preserving the end time). For allDay events, we want to change\n          // the end date to one day later than the drop date because end dates are exclusive\n          end = allDay ? _dates2.default.add(value, 1, 'day') : _dates2.default.merge(value, end);\n          break;\n\n        default:\n          return;\n        // don't issue resize\n      } // fall here for all of the resize cases\n      // note: the 'drop' param is here for backward compatibility - maybe remove in future?\n\n\n      onEventResize('drop', {\n        event: event,\n        start: start,\n        end: end,\n        resourceId: resource,\n        allDay: droppedInAllDay\n      });\n    }\n  };\n  return (0, _reactDnd.DropTarget)('event', dropTarget, collectTarget)(DropWrapper);\n}\n\nvar DroppableDateCellWrapper = exports.DroppableDateCellWrapper = createDropWrapper('dateCellWrapper');\nvar DroppableDayWrapper = exports.DroppableDayWrapper = createDropWrapper('dayWrapper');","map":null,"metadata":{},"sourceType":"script"}