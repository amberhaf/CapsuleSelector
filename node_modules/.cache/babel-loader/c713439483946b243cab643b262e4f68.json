{"ast":null,"code":"var instances = 'ej2_instances';\nvar uid = 0;\nvar isBlazorPlatform = false;\n/**\r\n * Function to check whether the platform is blazor or not.\r\n * @return {boolean} result\r\n * @private\r\n */\n\nexport function disableBlazorMode() {\n  isBlazorPlatform = false;\n}\n/**\r\n * Create Instance from constructor function with desired parameters.\r\n * @param {Function} classFunction - Class function to which need to create instance\r\n * @param {any[]} params - Parameters need to passed while creating instance\r\n * @return {any}\r\n * @private\r\n */\n\nexport function createInstance(classFunction, params) {\n  var arrayParam = params;\n  arrayParam.unshift(undefined);\n  return new (Function.prototype.bind.apply(classFunction, arrayParam))();\n}\n/**\r\n * To run a callback function immediately after the browser has completed other operations.\r\n * @param {Function} handler - callback function to be triggered.\r\n * @return {Function}\r\n * @private\r\n */\n\nexport function setImmediate(handler) {\n  var unbind;\n  var num = new Uint16Array(5);\n  var intCrypto = window.msCrypto || window.crypto;\n  intCrypto.getRandomValues(num);\n  var secret = 'ej2' + combineArray(num);\n\n  var messageHandler = function messageHandler(event) {\n    if (event.source === window && typeof event.data === 'string' && event.data.length <= 32 && event.data === secret) {\n      handler();\n      unbind();\n    }\n  };\n\n  window.addEventListener('message', messageHandler, false);\n  window.postMessage(secret, '*');\n  return unbind = function unbind() {\n    window.removeEventListener('message', messageHandler);\n    handler = messageHandler = secret = undefined;\n  };\n}\n/**\r\n * To get nameSpace value from the desired object.\r\n * @param {string} nameSpace - String value to the get the inner object\r\n * @param {any} obj - Object to get the inner object value.\r\n * @return {any}\r\n * @private\r\n */\n\nexport function getValue(nameSpace, obj) {\n  /* tslint:disable no-any */\n  var value = obj;\n  var splits = nameSpace.replace(/\\[/g, '.').replace(/\\]/g, '').split('.');\n\n  for (var i = 0; i < splits.length && !isUndefined(value); i++) {\n    value = value[splits[i]];\n  }\n\n  return value;\n}\n/**\r\n * To set value for the nameSpace in desired object.\r\n * @param {string} nameSpace - String value to the get the inner object\r\n * @param {any} value - Value that you need to set.\r\n * @param {any} obj - Object to get the inner object value.\r\n * @return {void}\r\n * @private\r\n */\n\nexport function setValue(nameSpace, value, obj) {\n  var keys = nameSpace.replace(/\\[/g, '.').replace(/\\]/g, '').split('.');\n  var start = obj || {};\n  var fromObj = start;\n  var i;\n  var length = keys.length;\n  var key;\n\n  for (i = 0; i < length; i++) {\n    key = keys[i];\n\n    if (i + 1 === length) {\n      fromObj[key] = value === undefined ? {} : value;\n    } else if (isNullOrUndefined(fromObj[key])) {\n      fromObj[key] = {};\n    }\n\n    fromObj = fromObj[key];\n  }\n\n  return start;\n}\n/**\r\n * Delete an item from Object\r\n * @param {any} obj - Object in which we need to delete an item.\r\n * @param {string} params - String value to the get the inner object\r\n * @return {void}\r\n * @private\r\n */\n\nexport function deleteObject(obj, key) {\n  delete obj[key];\n}\n/**\r\n * Check weather the given argument is only object.\r\n * @param {any} obj - Object which is need to check.\r\n * @return {boolean}\r\n * @private\r\n */\n\nexport function isObject(obj) {\n  var objCon = {};\n  return !isNullOrUndefined(obj) && obj.constructor === objCon.constructor;\n}\n/**\r\n * To get enum value by giving the string.\r\n * @param {any} enumObject - Enum object.\r\n * @param {string} enumValue - Enum value to be searched\r\n * @return {any}\r\n * @private\r\n */\n\nexport function getEnumValue(enumObject, enumValue) {\n  return enumObject[enumValue];\n}\n/**\r\n * Merge the source object into destination object.\r\n * @param {any} source - source object which is going to merge with destination object\r\n * @param {any} destination - object need to be merged\r\n * @return {void}\r\n * @private\r\n */\n\nexport function merge(source, destination) {\n  if (!isNullOrUndefined(destination)) {\n    var temrObj = source;\n    var tempProp = destination;\n    var keys = Object.keys(destination);\n    var deepmerge = 'deepMerge';\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n\n      if (!isNullOrUndefined(temrObj[deepmerge]) && temrObj[deepmerge].indexOf(key) !== -1 && (isObject(tempProp[key]) || Array.isArray(tempProp[key]))) {\n        extend(temrObj[key], temrObj[key], tempProp[key], true);\n      } else {\n        temrObj[key] = tempProp[key];\n      }\n    }\n  }\n}\n/**\r\n * Extend the two object with newer one.\r\n * @param {any} copied - Resultant object after merged\r\n * @param {Object} first - First object need to merge\r\n * @param {Object} second - Second object need to merge\r\n * @return {Object}\r\n * @private\r\n */\n\nexport function extend(copied, first, second, deep) {\n  var result = copied && typeof copied === 'object' ? copied : {};\n  var length = arguments.length;\n\n  if (deep) {\n    length = length - 1;\n  }\n\n  var _loop_1 = function _loop_1(i) {\n    if (!arguments_1[i]) {\n      return \"continue\";\n    }\n\n    var obj1 = arguments_1[i];\n    Object.keys(obj1).forEach(function (key) {\n      var src = result[key];\n      var copy = obj1[key];\n      var clone;\n      var isArrayChanged = Array.isArray(copy) && Array.isArray(src) && copy.length !== src.length;\n      var blazorEventExtend = isBlazor() ? !(src instanceof Event) && !isArrayChanged : true;\n\n      if (deep && blazorEventExtend && (isObject(copy) || Array.isArray(copy))) {\n        if (isObject(copy)) {\n          clone = src ? src : {};\n\n          if (Array.isArray(clone) && clone.hasOwnProperty('isComplexArray')) {\n            extend(clone, {}, copy, deep);\n          } else {\n            result[key] = extend(clone, {}, copy, deep);\n          }\n        } else {\n          /* istanbul ignore next */\n          clone = isBlazor() ? src && Object.keys(copy).length : src ? src : [];\n          result[key] = extend([], clone, copy, deep);\n        }\n      } else {\n        result[key] = copy;\n      }\n    });\n  };\n\n  var arguments_1 = arguments;\n\n  for (var i = 1; i < length; i++) {\n    _loop_1(i);\n  }\n\n  return result;\n}\n/**\r\n * To check whether the object is null or undefined.\r\n * @param {Object} value - To check the object is null or undefined\r\n * @return {boolean}\r\n * @private\r\n */\n\nexport function isNullOrUndefined(value) {\n  return value === undefined || value === null;\n}\n/**\r\n * To check whether the object is undefined.\r\n * @param {Object} value - To check the object is undefined\r\n * @return {boolean}\r\n * @private\r\n */\n\nexport function isUndefined(value) {\n  return 'undefined' === typeof value;\n}\n/**\r\n * To return the generated unique name\r\n * @param {string} definedName - To concatenate the unique id to provided name\r\n * @return {string}\r\n * @private\r\n */\n\nexport function getUniqueID(definedName) {\n  return definedName + '_' + uid++;\n}\n/**\r\n * It limits the rate at which a function can fire. The function will fire only once every provided second instead of as quickly.\r\n * @param {Function} eventFunction - Specifies the function to run when the event occurs\r\n * @param {number} delay - A number that specifies the milliseconds for function delay call option\r\n * @return {Function}\r\n * @private\r\n */\n\nexport function debounce(eventFunction, delay) {\n  var out; // tslint:disable-next-line\n\n  return function () {\n    var _this = this;\n\n    var args = arguments;\n\n    var later = function later() {\n      out = null;\n      return eventFunction.apply(_this, args);\n    };\n\n    clearTimeout(out);\n    out = setTimeout(later, delay);\n  };\n} // Added since lint ignored after added '//tslint:disable-next-line' \n\n/* tslint:disable:no-any */\n\n/**\r\n * To convert the object to string for query url\r\n * @param  {Object} data\r\n * @returns string\r\n * @private\r\n */\n\nexport function queryParams(data) {\n  var array = [];\n  var keys = Object.keys(data);\n\n  for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n    var key = keys_2[_i];\n    array.push(encodeURIComponent(key) + '=' + encodeURIComponent('' + data[key]));\n  }\n\n  return array.join('&');\n}\n/**\r\n * To check whether the given array contains object.\r\n * @param {T[]} value- Specifies the T type array to be checked.\r\n * @private\r\n */\n\nexport function isObjectArray(value) {\n  var parser = Object.prototype.toString;\n\n  if (parser.call(value) === '[object Array]') {\n    if (parser.call(value[0]) === '[object Object]') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * To check whether the  child element is descendant to parent element or parent and child are same element.\r\n * @param{Element} - Specifies the child element to compare with parent.\r\n * @param{Element} - Specifies the parent element.\r\n * @return boolean\r\n * @private\r\n */\n\nexport function compareElementParent(child, parent) {\n  var node = child;\n\n  if (node === parent) {\n    return true;\n  } else if (node === document || !node) {\n    return false;\n  } else {\n    return compareElementParent(node.parentNode, parent);\n  }\n}\n/**\r\n * To throw custom error message.\r\n * @param{string} - Specifies the error message to be thrown.\r\n * @private\r\n */\n\nexport function throwError(message) {\n  try {\n    throw new Error(message);\n  } catch (e) {\n    throw e.message + '\\n' + e.stack;\n  }\n}\n/**\r\n * This function is used to print given element\r\n * @param{Element} element - Specifies the print content element.\r\n * @param{Window} printWindow - Specifies the print window.\r\n * @private\r\n */\n\nexport function print(element, printWindow) {\n  var div = document.createElement('div');\n  var links = [].slice.call(document.getElementsByTagName('head')[0].querySelectorAll('base, link, style'));\n  var reference = '';\n\n  if (isNullOrUndefined(printWindow)) {\n    printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');\n  }\n\n  div.appendChild(element.cloneNode(true));\n\n  for (var i = 0, len = links.length; i < len; i++) {\n    reference += links[i].outerHTML;\n  }\n\n  printWindow.document.write('<!DOCTYPE html> <html><head>' + reference + '</head><body>' + div.innerHTML + '<script> (function() { window.ready = true; })(); </script>' + '</body></html>');\n  printWindow.document.close();\n  printWindow.focus(); // tslint:disable-next-line\n\n  var interval = setInterval(function () {\n    if (printWindow.ready) {\n      printWindow.print();\n      printWindow.close();\n      clearInterval(interval);\n    }\n  }, 500);\n  return printWindow;\n}\n/**\r\n * Function to normalize the units applied to the element.\r\n * @param  {number|string} value\r\n * @return {string} result\r\n * @private\r\n */\n\nexport function formatUnit(value) {\n  var result = value + '';\n\n  if (result.match(/auto|%|px|vh|vm|vmax|vmin|em/)) {\n    return result;\n  }\n\n  return result + 'px';\n}\n/**\r\n * Function to check whether the platform is blazor or not.\r\n * @return {boolean} result\r\n * @private\r\n */\n\nexport function enableBlazorMode() {\n  isBlazorPlatform = true;\n}\n/**\r\n * Function to check whether the platform is blazor or not.\r\n * @return {boolean} result\r\n * @private\r\n */\n\nexport function isBlazor() {\n  return isBlazorPlatform;\n}\n/**\r\n * Function to convert xPath to DOM element in blazor platform\r\n * @return {HTMLElement} result\r\n * @param {HTMLElement | object} element\r\n * @private\r\n */\n\nexport function getElement(element) {\n  var xPath = 'xPath';\n\n  if (!(element instanceof Node) && isBlazor() && !isNullOrUndefined(element[xPath])) {\n    return document.evaluate(element[xPath], document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n  }\n\n  return element;\n}\n/**\r\n * Function to fetch the Instances of a HTML element for the given component.\r\n * @param {string | HTMLElement} element\r\n * @param {any} component\r\n * @return {Object} inst\r\n * @private\r\n */\n// tslint:disable-next-line\n\nexport function getInstance(element, component) {\n  // tslint:disable-next-line:no-any\n  var elem = typeof element === 'string' ? document.querySelector(element) : element;\n\n  if (elem[instances]) {\n    for (var _i = 0, _a = elem[instances]; _i < _a.length; _i++) {\n      var inst = _a[_i];\n\n      if (inst instanceof component) {\n        return inst;\n      }\n    }\n  }\n\n  return null;\n}\n/**\r\n * Function to add instances for the given element.\r\n * @param {string | HTMLElement} element\r\n * @param {Object} instance\r\n * @return {void}\r\n * @private\r\n */\n\nexport function addInstance(element, instance) {\n  // tslint:disable-next-line:no-any\n  var elem = typeof element === 'string' ? document.querySelector(element) : element;\n\n  if (elem[instances]) {\n    elem[instances].push(instance);\n  } else {\n    elem[instances] = [instance];\n  }\n}\n/**\r\n * Function to generate the unique id.\r\n * @return {any}\r\n * @private\r\n */\n// tslint:disable-next-line:no-any\n\nexport function uniqueID() {\n  // tslint:disable-next-line:no-any\n  if (typeof window === 'undefined') {\n    return;\n  } // tslint:disable-next-line:no-any\n\n\n  var num = new Uint16Array(5);\n  var intCrypto = window.msCrypto || window.crypto;\n  return intCrypto.getRandomValues(num);\n}\n\nfunction combineArray(num) {\n  var ret = '';\n\n  for (var i = 0; i < 5; i++) {\n    ret += (i ? ',' : '') + num[i];\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}