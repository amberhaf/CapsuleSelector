{"ast":null,"code":"'use strict';\n/**\n * @author Sebastian Pekarek\n * @module event\n * @constructor ICalEvent Event\n */\n\nvar ICalEvent = function ICalEvent(_data, calendar) {\n  var attributes = ['id', 'uid', 'sequence', 'start', 'end', 'timezone', 'stamp', 'timestamp', 'allDay', 'floating', 'repeating', 'summary', 'location', 'description', 'organizer', 'attendees', 'alarms', 'method', 'status', 'url'],\n      vars,\n      i,\n      data;\n\n  if (!calendar) {\n    throw '`calendar` option required!';\n  }\n\n  vars = {\n    allowedRepeatingFreq: ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'],\n    allowedStatuses: ['CONFIRMED', 'TENTATIVE', 'CANCELLED']\n  };\n  data = {\n    id: ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).substr(-4),\n    sequence: 0,\n    start: null,\n    end: null,\n    timezone: undefined,\n    stamp: new Date(),\n    allDay: false,\n    floating: false,\n    repeating: null,\n    summary: '',\n    location: null,\n    description: null,\n    htmlDescription: null,\n    organizer: null,\n    attendees: [],\n    alarms: [],\n    status: null,\n    url: null\n  };\n  /**\n   * Set/Get the event's ID\n   *\n   * @param id ID\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n  this.id = function (id) {\n    if (!id) {\n      return data.id;\n    }\n\n    data.id = id;\n    return this;\n  };\n  /**\n   * Set/Get the event's ID\n   *\n   * @param id ID\n   * @since 0.2.0\n   * @alias id\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.uid = this.id;\n  /**\n   * Set/Get the event's SEQUENCE number\n   *\n   * @param {Number} sequence\n   * @since 0.2.6\n   * @returns {ICalEvent|Number}\n   */\n\n  this.sequence = function (sequence) {\n    if (sequence === undefined) {\n      return data.sequence;\n    }\n\n    var s = parseInt(sequence, 10);\n\n    if (isNaN(s)) {\n      throw '`sequence` must be a number!';\n    }\n\n    data.sequence = s;\n    return this;\n  };\n  /**\n   * Set/Get the event's start date\n   *\n   * @param {Date} start\n   * @since 0.2.0\n   * @returns {ICalEvent|Date}\n   */\n\n\n  this.start = function (start) {\n    if (!start) {\n      return data.start;\n    }\n\n    if (typeof start === 'string') {\n      start = new Date(start);\n    }\n\n    if (!(start instanceof Date) || isNaN(start.getTime())) {\n      throw '`start` must be a Date Object!';\n    }\n\n    data.start = start;\n\n    if (data.start && data.end && data.start > data.end) {\n      var t = data.start;\n      data.start = data.end;\n      data.end = t;\n    }\n\n    return this;\n  };\n  /**\n   * Set/Get the event's end date\n   *\n   * @param {Date} end\n   * @since 0.2.0\n   * @returns {ICalEvent|Date}\n   */\n\n\n  this.end = function (end) {\n    if (end === undefined) {\n      return data.end;\n    }\n\n    if (!end) {\n      data.end = null;\n      return this;\n    }\n\n    if (typeof end === 'string') {\n      end = new Date(end);\n    }\n\n    if (!(end instanceof Date) || isNaN(end.getTime())) {\n      throw '`end` must be a Date Object!';\n    }\n\n    data.end = end;\n\n    if (data.start && data.end && data.start > data.end) {\n      var t = data.start;\n      data.start = data.end;\n      data.end = t;\n    }\n\n    return this;\n  };\n  /**\n   * Set/Get the event's timezone.  This unsets the event's floating flag.\n   * Used on date properties\n   *\n   * @param [timezone] Timezone\n   * @example event.timezone('America/New_York');\n   * @since 0.2.6\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.timezone = function (timezone) {\n    if (timezone === undefined && data.timezone !== undefined) {\n      return data.timezone;\n    }\n\n    if (timezone === undefined) {\n      return calendar.timezone();\n    }\n\n    data.timezone = timezone ? timezone.toString() : null;\n\n    if (data.timezone) {\n      data.floating = false;\n    }\n\n    return this;\n  };\n  /**\n   * Set/Get the event's timestamp\n   *\n   * @param {Date} stamp\n   * @since 0.2.0\n   * @returns {ICalEvent|Date}\n   */\n\n\n  this.stamp = function (stamp) {\n    if (!stamp) {\n      return data.stamp;\n    }\n\n    if (typeof stamp === 'string') {\n      stamp = new Date(stamp);\n    }\n\n    if (!(stamp instanceof Date) || isNaN(stamp.getTime())) {\n      throw '`stamp` must be a Date Object!';\n    }\n\n    data.stamp = stamp;\n    return this;\n  };\n  /**\n   * SetGet the event's timestamp\n   *\n   * @param {Date} stamp\n   * @since 0.2.0\n   * @alias stamp\n   * @returns {ICalEvent|Date}\n   */\n\n\n  this.timestamp = this.stamp;\n  /**\n   * Set/Get the event's allDay flag\n   *\n   * @param {Boolean} allDay\n   * @since 0.2.0\n   * @returns {ICalEvent|Boolean}\n   */\n\n  this.allDay = function (allDay) {\n    if (allDay === undefined) {\n      return data.allDay;\n    }\n\n    data.allDay = !!allDay;\n    return this;\n  };\n  /**\n   * Set/Get the event's floating flag.  This unsets the event's timezone.\n   * See https://tools.ietf.org/html/rfc5545#section-3.3.12\n   *\n   * @param {Boolean} floating\n   * @since 0.2.0\n   * @returns {ICalEvent|Boolean}\n   */\n\n\n  this.floating = function (floating) {\n    if (floating === undefined) {\n      return data.floating;\n    }\n\n    data.floating = !!floating;\n\n    if (data.floating) {\n      data.timezone = null;\n    }\n\n    return this;\n  };\n  /**\n   * Set/Get the event's repeating stuff\n   *\n   * @param repeating\n   * @since 0.2.0\n   * @returns {ICalEvent|Object}\n   */\n\n\n  this.repeating = function (repeating) {\n    if (repeating === undefined) {\n      return data.repeating;\n    }\n\n    if (!repeating) {\n      data.repeating = null;\n      return this;\n    }\n\n    if (!repeating.freq || vars.allowedRepeatingFreq.indexOf(repeating.freq.toUpperCase()) === -1) {\n      throw '`repeating.freq` is a mandatory item, and must be one of the following: ' + vars.allowedRepeatingFreq.join(', ') + '!';\n    }\n\n    data.repeating = {\n      freq: repeating.freq.toUpperCase()\n    };\n\n    if (repeating.count) {\n      if (!isFinite(repeating.count)) {\n        throw '`repeating.count` must be a Number!';\n      }\n\n      data.repeating.count = repeating.count;\n    }\n\n    if (repeating.interval) {\n      if (!isFinite(repeating.interval)) {\n        throw '`repeating.interval` must be a Number!';\n      }\n\n      data.repeating.interval = repeating.interval;\n    }\n\n    if (repeating.until) {\n      if (typeof repeating.until === 'string') {\n        repeating.until = new Date(repeating.until);\n      }\n\n      if (!(repeating.until instanceof Date) || isNaN(repeating.until.getTime())) {\n        throw '`repeating.until` must be a Date Object!';\n      }\n\n      data.repeating.until = repeating.until;\n    }\n\n    if (repeating.byDay) {\n      if (!Array.isArray(repeating.byDay)) {\n        repeating.byDay = [repeating.byDay];\n      }\n\n      data.repeating.byDay = [];\n      repeating.byDay.forEach(function (symbol) {\n        var s = symbol.toString().toUpperCase().match(/^(\\d*||-\\d+)(\\w+)$/);\n\n        if (['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'].indexOf(s[2]) === -1) {\n          throw '`repeating.byDay` contains invalid value `' + s[2] + '`!';\n        }\n\n        data.repeating.byDay.push(s[1] + s[2]);\n      });\n    }\n\n    if (repeating.byMonth) {\n      if (!Array.isArray(repeating.byMonth)) {\n        repeating.byMonth = [repeating.byMonth];\n      }\n\n      data.repeating.byMonth = [];\n      repeating.byMonth.forEach(function (month) {\n        if (typeof month !== 'number' || month < 1 || month > 12) {\n          throw '`repeating.byMonth` contains invalid value `' + month + '`!';\n        }\n\n        data.repeating.byMonth.push(month);\n      });\n    }\n\n    if (repeating.byMonthDay) {\n      if (!Array.isArray(repeating.byMonthDay)) {\n        repeating.byMonthDay = [repeating.byMonthDay];\n      }\n\n      data.repeating.byMonthDay = [];\n      repeating.byMonthDay.forEach(function (monthDay) {\n        if (typeof monthDay !== 'number' || monthDay < 1 || monthDay > 31) {\n          throw '`repeating.byMonthDay` contains invalid value `' + monthDay + '`!';\n        }\n\n        data.repeating.byMonthDay.push(monthDay);\n      });\n    }\n\n    if (repeating.exclude) {\n      if (!Array.isArray(repeating.exclude)) {\n        repeating.exclude = [repeating.exclude];\n      }\n\n      data.repeating.exclude = [];\n      repeating.exclude.forEach(function (excludedDate) {\n        var originalDate = excludedDate;\n\n        if (typeof excludedDate === 'string') {\n          excludedDate = new Date(excludedDate);\n        }\n\n        if (Object.prototype.toString.call(excludedDate) !== '[object Date]' || isNaN(excludedDate.getTime())) {\n          throw '`repeating.exclude` contains invalid value `' + originalDate + '`!';\n        }\n\n        data.repeating.exclude.push(excludedDate);\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Set/Get the event's summary\n   *\n   * @param {String} summary\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.summary = function (summary) {\n    if (summary === undefined) {\n      return data.summary;\n    }\n\n    data.summary = summary ? summary.toString() : '';\n    return this;\n  };\n  /**\n   * Set/Get the event's location\n   *\n   * @param {String} location\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.location = function (location) {\n    if (location === undefined) {\n      return data.location;\n    }\n\n    data.location = location ? location.toString() : null;\n    return this;\n  };\n  /**\n   * Set/Get the event's description\n   *\n   * @param {String} description\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.description = function (description) {\n    if (description === undefined) {\n      return data.description;\n    }\n\n    data.description = description ? description.toString() : null;\n    return this;\n  };\n  /**\n   * Set/Get the event's HTML description\n   *\n   * @param {String} description\n   * @since 0.2.8\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.htmlDescription = function (htmlDescription) {\n    if (htmlDescription === undefined) {\n      return data.htmlDescription;\n    }\n\n    data.htmlDescription = htmlDescription ? htmlDescription.toString() : null;\n    return this;\n  };\n  /**\n   * Set/Get the event's organizer\n   *\n   * @param {Object} organizer\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.organizer = function (_organizer) {\n    if (_organizer === undefined) {\n      return data.organizer;\n    }\n\n    if (!_organizer) {\n      data.organizer = null;\n      return this;\n    }\n\n    var organizer = null,\n        organizerRegEx = /^(.+) ?<([^>]+)>$/;\n\n    if (typeof _organizer === 'string' && organizerRegEx.test(_organizer)) {\n      organizer = {\n        name: RegExp.$1.trim(),\n        email: RegExp.$2\n      };\n    } else if (typeof _organizer === 'object') {\n      organizer = {\n        name: _organizer.name,\n        email: _organizer.email\n      };\n    } else if (typeof _organizer === 'string') {\n      throw '`organizer` isn\\'t formated correctly. See https://github.com/sebbo2002/ical-generator#organizerstringobject-organizer';\n    } else {\n      throw '`organizer` needs to be a valid formed string or an object. See https://github.com/sebbo2002/ical-generator#organizerstringobject-organizer';\n    }\n\n    if (!organizer.name) {\n      throw '`organizer.name` is empty!';\n    }\n\n    if (!organizer.email) {\n      throw '`organizer.email` is empty!';\n    }\n\n    data.organizer = {\n      name: organizer.name,\n      email: organizer.email\n    };\n    return this;\n  };\n  /**\n   * Create a new Attendee and return the attendee object…\n   *\n   * @param [attendeeData] Attendee-Options\n   * @since 0.2.0\n   * @returns {ICalAttendee}\n   */\n\n\n  this.createAttendee = function (_attendeeData) {\n    var ICalAttendee = require('./attendee.js'),\n        attendeeRegEx = /^(.+) ?<([^>]+)>$/,\n        attendee;\n\n    if (typeof _attendeeData === 'string' && attendeeRegEx.test(_attendeeData)) {\n      attendee = new ICalAttendee({\n        name: RegExp.$1.trim(),\n        email: RegExp.$2\n      }, this);\n      data.attendees.push(attendee);\n      return attendee;\n    }\n\n    if (typeof _attendeeData === 'string') {\n      throw '`attendee` isn\\'t formated correctly. See https://github.com/sebbo2002/ical-generator#createattendeeobject-options';\n    }\n\n    attendee = new ICalAttendee(_attendeeData, this);\n    data.attendees.push(attendee);\n    return attendee;\n  };\n  /**\n   * Get all attendees or add attendees…\n   *\n   * @since 0.2.0\n   * @returns {ICalAttendees[]|ICalEvent}\n   */\n\n\n  this.attendees = function (attendees) {\n    if (!attendees) {\n      return data.attendees;\n    }\n\n    var cal = this;\n    attendees.forEach(function (e) {\n      cal.createAttendee(e);\n    });\n    return cal;\n  };\n  /**\n   * Create a new Alarm and return the alarm object…\n   *\n   * @param [alarmData] Alarm-Options\n   * @since 0.2.1\n   * @returns {ICalAlarm}\n   */\n\n\n  this.createAlarm = function (alarmData) {\n    var ICalAlarm = require('./alarm.js'),\n        alarm = new ICalAlarm(alarmData, this);\n\n    data.alarms.push(alarm);\n    return alarm;\n  };\n  /**\n   * Get all alarms or add alarms…\n   *\n   * @since 0.2.0\n   * @returns {ICalAlarms[]|ICalEvent}\n   */\n\n\n  this.alarms = function (alarms) {\n    if (!alarms) {\n      return data.alarms;\n    }\n\n    var cal = this;\n    alarms.forEach(function (e) {\n      cal.createAlarm(e);\n    });\n    return cal;\n  };\n  /**\n   * Set/Get your feed's method\n   *\n   * @param {String} method\n   * @since 0.2.0\n   * @deprecated since 0.2.8\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.method = function (method) {\n    if (method === undefined) {\n      return calendar.method();\n    }\n\n    if (!method) {\n      calendar.method(null);\n      return this;\n    }\n\n    calendar.method(method);\n    return this;\n  };\n  /**\n   * Set/Get the event's status\n   *\n   * @param {String} status\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.status = function (status) {\n    if (status === undefined) {\n      return data.status;\n    }\n\n    if (!status) {\n      data.status = null;\n      return this;\n    } // https://github.com/sebbo2002/ical-generator/issues/45\n\n\n    if (status === 'TENATIVE') {\n      status = 'TENTATIVE';\n    }\n\n    if (vars.allowedStatuses.indexOf(status.toUpperCase()) === -1) {\n      throw '`status` must be one of the following: ' + vars.allowedStatuses.join(', ') + '!';\n    }\n\n    data.status = status.toUpperCase();\n    return this;\n  };\n  /**\n   * Set/Get the event's URL\n   *\n   * @param {String} url URL\n   * @since 0.2.0\n   * @returns {ICalEvent|String}\n   */\n\n\n  this.url = function (url) {\n    if (url === undefined) {\n      return data.url;\n    }\n\n    data.url = url ? url.toString() : null;\n    return this;\n  };\n  /**\n   * Export calender as JSON Object to use it later…\n   *\n   * @since 0.2.4\n   * @returns Object Calendar\n   */\n\n\n  this.toJSON = function () {\n    var tools = require('./_tools.js');\n\n    return tools.toJSON(this, attributes);\n  };\n  /**\n   * Export Event to iCal\n   *\n   * @param {ICalCalendar}\n   * @since 0.2.0\n   * @returns {String}\n   */\n\n\n  this.generate = function (calendar) {\n    var tools = require('./_tools.js'),\n        g = '';\n\n    if (!calendar) {\n      throw '`calendar` option required!';\n    }\n\n    if (!data.start) {\n      throw 'No value for `start` in ICalEvent #' + data.id + ' given!';\n    }\n\n    if (data.timezone) {\n      data.floating = false;\n    } // DATE & TIME\n\n\n    g += 'BEGIN:VEVENT\\r\\n';\n    g += 'UID:' + data.id + '@' + calendar.domain() + '\\r\\n'; // SEQUENCE\n\n    g += 'SEQUENCE:' + data.sequence + '\\r\\n';\n    g += 'DTSTAMP:' + tools.formatDate(data.stamp) + '\\r\\n';\n\n    if (data.allDay) {\n      g += 'DTSTART;VALUE=DATE:' + tools.formatDate(data.start, true) + '\\r\\n';\n\n      if (data.end) {\n        g += 'DTEND;VALUE=DATE:' + tools.formatDate(data.end, true) + '\\r\\n';\n      }\n\n      g += 'X-MICROSOFT-CDO-ALLDAYEVENT:TRUE\\r\\n';\n      g += 'X-MICROSOFT-MSNCALENDAR-ALLDAYEVENT:TRUE\\r\\n';\n    } else {\n      g += tools.formatDateTZ('DTSTART', data.start, data) + '\\r\\n';\n\n      if (data.end) {\n        g += tools.formatDateTZ('DTEND', data.end, data) + '\\r\\n';\n      }\n    } // REPEATING\n\n\n    if (data.repeating) {\n      g += 'RRULE:FREQ=' + data.repeating.freq;\n\n      if (data.repeating.count) {\n        g += ';COUNT=' + data.repeating.count;\n      }\n\n      if (data.repeating.interval) {\n        g += ';INTERVAL=' + data.repeating.interval;\n      }\n\n      if (data.repeating.until) {\n        g += ';UNTIL=' + tools.formatDate(data.repeating.until);\n      }\n\n      if (data.repeating.byDay) {\n        g += ';BYDAY=' + data.repeating.byDay.join(',');\n      }\n\n      if (data.repeating.byMonth) {\n        g += ';BYMONTH=' + data.repeating.byMonth.join(',');\n      }\n\n      if (data.repeating.byMonthDay) {\n        g += ';BYMONTHDAY=' + data.repeating.byMonthDay.join(',');\n      }\n\n      g += '\\r\\n'; // REPEATING EXCLUSION\n\n      if (data.repeating.exclude) {\n        g += 'EXDATE:';\n        var sArr = [];\n        data.repeating.exclude.forEach(function (excludedDate) {\n          sArr.push(tools.formatDate(excludedDate));\n        });\n        g += sArr.join(',');\n        g += '\\r\\n';\n      }\n    } // SUMMARY\n\n\n    g += 'SUMMARY:' + tools.escape(data.summary) + '\\r\\n'; // LOCATION\n\n    if (data.location) {\n      g += 'LOCATION:' + tools.escape(data.location) + '\\r\\n';\n    } // DESCRIPTION\n\n\n    if (data.description) {\n      g += 'DESCRIPTION:' + tools.escape(data.description) + '\\r\\n';\n    } // HTML DESCRIPTION\n\n\n    if (data.htmlDescription) {\n      g += 'X-ALT-DESC;FMTTYPE=text/html:' + tools.escape(data.htmlDescription) + '\\r\\n';\n    } // ORGANIZER\n\n\n    if (data.organizer) {\n      g += 'ORGANIZER;CN=\"' + tools.escape(data.organizer.name) + '\":mailto:' + tools.escape(data.organizer.email) + '\\r\\n';\n    } // ATTENDEES\n\n\n    data.attendees.forEach(function (attendee) {\n      g += attendee.generate();\n    }); // ALARMS\n\n    data.alarms.forEach(function (alarm) {\n      g += alarm.generate();\n    }); // URL\n\n    if (data.url) {\n      g += 'URL;VALUE=URI:' + tools.escape(data.url) + '\\r\\n';\n    } // STATUS\n\n\n    if (data.status) {\n      g += 'STATUS:' + data.status.toUpperCase() + '\\r\\n';\n    }\n\n    g += 'END:VEVENT\\r\\n';\n    return g;\n  };\n\n  for (i in _data) {\n    if (_data.hasOwnProperty(i) && attributes.indexOf(i) > -1) {\n      this[i](_data[i]);\n    }\n  }\n};\n\nmodule.exports = ICalEvent;","map":null,"metadata":{},"sourceType":"script"}